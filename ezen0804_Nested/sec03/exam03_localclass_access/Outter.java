package ezen0804_Nested.sec03.exam03_localclass_access;

public class Outter {
	
	//자바7 이전
	public void method1(final int arg) {
		final int localVariable = 1;
		//arg = 100; (x)
		//localVariable = 100; (x)
		class Inner {
			public void method() {
				int result = arg + localVariable;
			}
		}
	}
	
	//자바8 이후          
	public void method2(int arg) { //매개변수 final 없음
		int localVariable = 1; //로컬변수 final 없음
		
		//arg = 100; (x)
		//localVariable = 100; (x) //final 키워드가 없지만 여전히 값의 수정이 불가함.
		class Inner {
			public void method() {
				int result = arg + localVariable;
			}
			//           *** PDF p.414 내용 참고 ***
			//로컬클래스 내부에서는 바깥 클래스의 필드/메소드를 제한없이 사용할 수 있다.
			//문제는 메소드의 매개변수나 로컬변수를 로컬클래스에서 사용할 때이다.
			//로컬클래스의 객체는 메소드실행이 끝나도 힙 메모리에 존재해서 계속 사용될 수 있다.
			//매개변수나 로컬변수는 메소드 실행이 끝나면 스택 메모리에서 사라지기 때문에 로컬 객체에서 사용할 경우 문제가 발생한다.
			//자바는 이 문제를 해결하기 위해 컴파일 시 로컬클래스에서 사용하는 매개변수, 로컬변수의 기억장소를
			//로컬클래스 내부에도 복사해두고 사용한다.
			//하지만 매개변수나 로컬변수가 수정되어 기억장소가 변경되면 로컬클래스 내에 복사해둔 기억장소와 달라지기 때문에
			//또 다른 문제가 생길 수 있고, 이를 막고자 매개변수나 로컬변수를 final로 선언해 수정을 막아왔다.
			//한마디로, 로컬클래스에서 사용가능한 것은 final로 선언된 매개변수와 로컬변수 뿐이었다.
			
			//하지만 자바8부터 바뀌었다.
			//그렇다면 자바8부터는 로컬클래스가 final로 선언되지 않은 매개변수와 로컬변수도 허용하는 걸까?
			//당연히 아니다.
			//final로 굳이 선언하지 않아도 값을 수정할 수 없는 특성을 갖게 되었다.
			//즉, 로컬클래스에서 사용할 수 있는 것은 final로 선언된 매개변수와 로컬변수 뿐이지만
			//이를 명시적으로 표시하지 않고 생략하여도 final 키워드가 있는 것으로 인식한다.
			//그래도 final 키워드를 적어주는 것과 생략하는 것의 차이가 있다면
			//final 키워드가 있다면 로컬클래스의 메소드 내부에 지역변수로 복사되고
			//final 키워드가 없다면 로컬클래스의 필드로 복사된다.
			//하지만 우리가 굳이 로컬클래스의 내부 복사위치에 신경 쓸 필요는 없으며
			
			//중요한 것은 **로컬클래스에서 사용된 매개변수와 로컬변수는 모두 final의 특성을 갖는다는 것이다.**
		}
	}
}   
